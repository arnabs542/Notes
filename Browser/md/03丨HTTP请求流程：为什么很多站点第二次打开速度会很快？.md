### HTTP请求流程 ：为什么很多站点第二次打开速度会很快？
![20200620200729](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200729.png)
#### 浏览器端发起HTTP请求
1. **构建请求**
```
GET /index.html HTTP1.1
```
2. **查找缓存**

浏览器缓存是一种在本地保存资源的副本，当请求还来访问这个资源时，浏览器会拦截请求，返回这个资源的的副本，并直接结束请求。

3. **准备IP地址和端口**

浏览器适应HTTP协议作为应用层协议，用来封装请求的问题信息。再使用TCP/IP作为传输层协议将其发到网络上，所以在HTTP开始工作之前需要通过TCP与服务器建立连接。
**HTTP的内容是通过TCP的传输数据阶段来实现的**。

![20200620200737](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200737.png)
<center>TCP 和 HTTP 的关系示意图</center>

在发送请求的时候，这个地方我们需要来理解一下什么是DNS。因为网站的IP地址不方便记忆，通常使用域名来访问网站，而当你使用域名来访问网站的时候，就会触发DNS域名系统的解析。**DNS会将我们输入的域名转化成IP地址，实际我们还是访问的IP地址**。

1. 等待TCP队列

通过3，准备好的IP地址和端口。这个时候，我们需要查看当前请求数量是否小于6。在Chrome中，同一个域名中最多只能建立6个TCP链接。小于6，则建立TCP链接。

5. 建立TCP链接

浏览器通过TCP与服务器建立链接。

6. 发送HTTP请求

建立TCP连接以后，浏览器就可以与服务器通信了。


![20200620200751](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200751.png)
<center>HTTP 请求数据格式</center>

**浏览器向服务器发送请求行**。请求行包括。请求方法、请求URL和HTTP版本协议。

GET：向服务器请求
POST：发送数据给服务器
请求体：使用POST发送准备的数据给服务器。
请求头：包含浏览器的基础信息，操作系统，浏览器内核，以及当前请求的域名信息、浏览器端的 Cookie 信息。

#### 服务器端HTTP请求流程

1. **返回请求**
```
curl -i  https://time.geekbang.org/
```

![20200620200800](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200800.png)
<center>服务器响应的数据格式</center>

- 首先浏览器会返回响应行，内包含协议版本和状态码。
**200 表成功，404 表没有找到界面**
- 而后，发送响应头。响应头包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。
- 发送完响应头，发送响应体，包含HTML实际内容。
1. **断开连接**

当服务器想请求客户端的信息就要断开连接。不过使用下面的代码就TCP连接在发送后仍然保持打开状态。**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**
```
Connection:Keep-Alive 
```
3. **重定向**

比如打开的是geekbang.org，然后你在地址栏可以看到是https://www.geekbang.org

```
curl -I geekbang.org
```


![20200620200813](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200813.png)
<center>服务器返回响应行和响应头（含重定向格式）</center>

**301就是告诉浏览器，我们要重定向到另一个网址**


**问题解答**
***
**为什么很多站点第二次打开速度会很快**

如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。

那么，哪些数据会被缓存呢？从上面介绍的核心请求路径可以发现，DNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。

![20200620200826](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200826.png)
<center>缓存查找流程示意图</center>

从上图的第一次请求可以看出，当服务器返回HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，我们还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的,缓存过期时间是 2000 秒。
```
Cache-Control:Max-age=2000
```

**如果缓存过期了，浏览器则会继续发起网络请求，并且在HTTP 请求头中带上**

```
If-None-Match:"4f80f-13c-3a1xb12a"
```

服务器收到请求头，根据If-None-Match的值来判断请求的资源是否有更新。
- 如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了。”
- 如果资源有更新，服务器就直接返回最新资源给浏览器。

1. **登录状态是如何保持的？**
- 用户输入用户名和密码，点击确定，这个时候会用POST方法发给服务器。
- 服务器接收到，查询后台验证用户输入的信息是否正确。正确的话，就生成字符串，把字符串写到Set-Cookie里，然后将响应头发送给浏览器。

```
Set-Cookie: UID=3431uad;
```
- 浏览器接收到想用头，解析，遇到有Set-Cookie，浏览器就会把这个字段信息保存到本地。eq：UID=3431uad
- 当用户在访问时候，发送HTTP请求，浏览器会读取之前存的Cookie数据，把数据写到请求头Cookie里，然后浏览器把这个请求头发给服务器。
```
Cookie: UID=3431uad;
```
- 服务器在收到HTTP请求头数据之后，会查找请求头里面Cookie字段信息。当查找到包含UID=3431uad的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。
- 览器在接收到该含有当前用户的页面数据后，就可以正确展示用户登录的状态信息了。
- 
![20200620200839](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200839.png)
<center>Cookie 流程图</center>

# 总结
![20200620200925](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620200925.png)
<center>HTTP 请求流程示意图</center>

从图中可以看到，浏览器中的 HTTP 请求从发起到结束一共经历了如下八个阶段：构建请求、查找缓存、准备 IP 和端口、等待 TCP 队列、建立 TCP 连接、发起 HTTP 请求、服务器处理请求、服务器返回请求和断开连接。

然后我还通过 HTTP 请求路径解答了两个经常会碰到的问题，一个涉及到了 Cache 流程，另外一个涉及到如何使用 Cookie 来进行状态管理。

**简单地说，如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。**