# 12 | 栈空间和堆空间：数据是如何存储的？

![20200620203458](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203458.png)



**JavaScript 的内存机制**

虽然 JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，我们还是需要了解数据在内存中的存储方式的。



## 让人疑惑的代码

```javascript
function foo(){
    var a = 1
    var b = a
    a = 2
    console.log(a)  // 2
    console.log(b)	// 1
}
foo()
```

```javascript
function foo(){
    var a = {name:" 极客时间 "}
    var b = a
    a.name = " 极客邦 " 
    console.log(a) // 极客邦
    console.log(b) // 极客邦
}
foo()
```

上面两段代码我们仅仅改变了a的name属性值，那为什么导致a和b都改变了呢？



## JavaScript是什么类型的语言

我们先来看段C代码

```c
int main()
{
   int a = 1;
   char* b = " 极客时间 ";
   bool c = true;
   return 0;
}
```

在C语言里面，我们把这种在使用之前就需要确认其变量数据类型的称为**静态语言**。

**动态语言**：在运行过程中需要检查数据类型的语言。例如：JavaScript。



虽然说C语言是静态，但是在C语言中，我们可以将其他类型的数据赋值给生命好的变量，比如

```c
c = a
```



前面的代码，我们将int型的变量a赋值给了bool变量c，这么代码还是可以正常编译执行的。C编译器会把int型的变量转换为 bool 型的变量，我们通常把这种偷偷转换的操作称为**隐式类型转换**。**支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言**。所以C和JavaScript都是弱类型语言。



对于各种语言的类型，我们可以参考下图：

![20200620203517](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203517.png)

<center>语言类型图</center>



## JavaScript 的数据类型

**JavaScript 是一种弱类型的、动态的语言**。

- **弱类型**，意味着你不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算出来。

- **动态**，意味着你可以使用同一个变量保存不同类型的数据。



下面我们来看下JavaScript数据类型。我们来看段代码：

```javascript
var bar
bar = 12 
bar = " 极客时间 "
bar = true
bar = null
bar = {name:" 极客时间 "}
```

在JavaScript，我们要查看一个变量到底是什么类型，可以使用"typeof"。

```JavaScript
var bar
console.log(typeof bar)  //undefined
bar = 12 
console.log(typeof bar) //number
bar = " 极客时间 "
console.log(typeof bar)//string
bar = true
console.log(typeof bar) //boolean
bar = null
console.log(typeof bar) //object
bar = {name:" 极客时间 "}
console.log(typeof bar) //object
```

***

JavaScript的数据类型一共有8种:

![20200620203526](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203526.png)


**注意点**

1. typeof（NULL），返回Object。属于BUG。

2. Object类型比较特殊，7个类型组成的一个包含了key-value对的数据类型。如：

   ```javascript
   let myObj = {
           name:'极客时间',
           update:function(){....}
           }
   ```

从中你可以看出来，Object 是由 key-value 组成的，其中的 vaule 可以是任何类型，包括函数，这也就意味着你可以通过 Object 来存储函数，Object 中的函数又称为**方法**，比如上述代码中的 update 方法。

3. **原始类型**：前七种。引用类型：对象。我们存放的位置是不一样的。

## 内存空间

 JavaScript 的内存模型

![20200620203540](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203540.png)

<center>JavaScript 内存模型</center>

从图中可以看出， 在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是**代码空间、栈空间**和**堆空间**。

其中的代码空间主要是存储可执行代码的。暂时展开。

### 栈空间和堆空间

这里的栈空间就是我们之前说的调用栈，是用来存储执行上下文的。我们来看段代码了解栈空间如何存储数据。

```javascript
function foo(){
    var a = " 极客时间 "
    var b = a
    var c = {name:" 极客时间 "}
    var d = c
}
foo()
```

当代码执行到第3行的时候，调用栈道图如下。

![20200620203547](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203547.png)

<center>执行到第 3 行时的调用栈状态图</center>

我们从上图可以看出，当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以我们认为a和b的值都是被存放在栈中的。继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型。**JavaScript引擎不是将这个对象存放在变量环境中，而是将它分配到堆中，然后给堆分配一个地址，然后将该数据的地址写进c的变量值，最终分配好内存**。如图：

![20200620203630](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203630.png)

	<center>对象类型是“堆”来存储</center>

​	从图中我们可以看出，对象类型是存放在堆空间，在栈内只保留了**引用**

，当JavaScript需要访问数据的时候，是通过栈的引用地址来访问的。



这个时候，我们应该知道了<font color=red>**原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的**。</font>

***

**那么这个时候又给我们带来了疑问？为什么数据不都存在栈中呢？**



**答**：JavaScript引擎需要用栈来维护程序执行期间的上下文的状态。如果栈的空间大了，所有的数据都放在栈内，那么会影响到切换执行上下文的效率，从而会影响到整个程序的执行。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：

![20200620203642](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203642.png)

<center>调用栈中切换执行上下文状态</center>

**通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据**。

引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，**堆空间很大，能存放很多大的数据**，不过缺点是分配内存和回收内存都会占用一定的时间。



***



我们来解释一下程序在执行过程中为什么需要堆和栈两种数据结构，我们继续看上端代码，这里我重新拷贝过来方便观看。

```javascript
function foo(){
    var a = " 极客时间 "
    var b = a
    var c = {name:" 极客时间 "}
    var d = c
}
foo()
```

在 JavaScript 中，赋值操作和其他语言有很大的不同，**原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址**。说白了，原始类型的赋值就是复制变量值，引用类型就是用箭头指向。



所以d=c的操作就是把 c 的引用地址赋值给 d，你可以参考下图：

![20200620203652](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203652.png)

<center>引用赋值</center>

变量 c 和变量 d 都指向了同一个堆中的对象，所以这就很好地解释了文章开头的那个问题，通过 c 修改 name 的值，变量 d 的值也跟着改变，**归根结底它们是同一个对象**。



### 再谈闭包

```javascript
function foo() {
    var myName = " 极客时间 "
    let test1 = 1
    const test2 = 2
    var innerBar = { 
        setName:function(newName){
            myName = newName
        },
        getName:function(){
            console.log(test1)
            return myName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName(" 极客邦 ")
bar.getName()
console.log(bar.getName())
```

由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。**但是我们之前讲过，这个地方出现了闭包。由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中**

<font color=red>那么如何来解释这个现象呢？</font>

1. 当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。
2. 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建换一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。
3. 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。
4. 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。



通过上面的分析，我们可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：

![20200620203702](https://hzy-1301560453.cos.ap-shanghai.myqcloud.com/2020/pictures/20200620203702.png)
<center>闭包的产生过程</center>

从上图你可以清晰地看出，当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“clourse(foo)”对象，所以即使 foo 函数退出了，“clourse(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用`bar.setName`或者`bar.getName`时，创建的执行上下文中就包含了“clourse(foo)”。

***

**总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。**

***

<font color=red>总结：</font>

1. JavaScript 中的 8 种数据类型，它们可以分为两大类——**原始类型和引用类型**
2. 原始类型的数据是存放在**栈**中，引用类型的数据是存放在**堆**中的。。堆中的数据是通过引用和变量关联起来的。
3. avaScript 中将一个原始类型的变量 a 赋值给 b，那么 a 和 b 会相互独立、互不影响；但是将引用类型的变量 a 赋值给变量 b，那会导致 a、b 两个变量都同时指向了堆中的同一块数据。
4. 内存模型的视角分析了闭包的产生过程。



日更：2020-05-25 22:32:35