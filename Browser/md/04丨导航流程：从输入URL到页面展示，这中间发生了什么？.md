## 导航流程：从输入URL到页面展示，这中间发生了什么？

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/17222fafbd1d7149-20200525145046385.png)
<center>从输入 URL 到页面展示完整流程示意图</center>


**从输入 URL 到页面展示**

**1. 用户输入**

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。
- 搜索内容，地址栏使用浏览器默认搜索引擎，合成新的带有搜索关键字的URL
- 输入内容符合URL规则:比图baidu.com,那么地址栏补充https://www.baidu.com 但是在刚加载的时候，标签页会显示之前打开页面的内容，因为需要等待提交文档阶段，那个时候页面内容才会被替换。

**2.URL请求**

- 浏览器进程发送URL给网络进程->网络进程接受请求后,真正发起URL请求->先查本地缓存,如果有则直接返回资源给浏览器进程/如果没有,则查找资源没，直接进入网络请求流程->请求前第一步DNS解析，获取IP地址。如果是HTTPS，还需建立TLS连接
- ->接下来利用IP和服务器建立TCP连接->浏览器构建请求行，请求头，将域名和Cookie添加到请求头上->向服务器发送构建请求信息。->
- 服务器接受请求，生成响应数据(包含响应行、响应头和响应体)->将响应数据发送给网络进程->网络接受响应头和响应行，解析响应头内容。

**(1)重定向**

接受到服务器返回到响应头，网络进程开始解析响应头。查看状态码301和302，那服务器需要浏览器重定向URL。这个时候网络进程就会从响应头的Location字段内读出重定向地址，然后重新发起一次HTTP或HTTPS请求。重复之前的请求，操作。

```
curl -I http://time.geekbang.org/
```
执行上述代码，返回内容如下图

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/172232db663f5856-20200525145059198.png)
<center>响应行返回状态码 301</center>

图中可以看出，极客时间会把HTTP都转换成HTTPS。服务器会返回301或者302，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。

我们再使用 HTTPS 协议对极客时间发起请求，看看服务器的响应头信息是什么样子的。


```
curl -I https://time.geekbang.org/
```

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/1722330011bb5e0a.png)
<center>响应行返回状态码 200</center>

上图为服务器返回的响应头数据。返回的状态码是200，表正常，可以继续处理请求。

**总结：在导航过程中，如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。**

**（2）响应数据类型处理**
URL的请求，有的时候是下载类型，有的时候是HTML页面。那么浏览器怎么来区分是哪个呢？

答：Content-Type 是 HTTP 头中告诉浏览器服务器返回的响应体数据是什么类型。然后浏览器根据Content-Type来决定按照哪种方式来显示响应体的内容。

```
curl -I https://time.geekbang.org/
```

返回信息如下图：
![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/172233596a414e6e.png)

<center>含有 HTML 格式的 Content-Type</center>

图中可以看到：Content-Type的值是html

我们再访问下安装包的地址，看看返回什么
```
curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk
```

图中可以看到：Content-Type的值是application/octet-stream，**显示数据是字节流类型**，这个时候，浏览器就会下载这个文件。

**3.准备渲染进程**
默认，Chrome只运行一个渲染进程，每打开一个新页面就会配套创建一个新的渲染进程。不过，有些时候浏览器会让多个页面直接运行在同一个渲染进程中。

**比如：**

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/172233a66f84e817.png)
<center>多个页面运行在一个渲染进程中</center>

上图：进程 ID 都是 23601

**根据上图引发我们深思，啥时候会让浏览器开多个页面的时候运行在一个渲染进程中呢？**

答：属于同一个站点的，根域名都是一样的，不同的网页知识加上了不同的协议或者端口。


**Chrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程。官方成为<font color=red>process-per-site-instance</font>**

**那么新的问题出现了，新页面和当前页面不属于同一站点，情况又会发生什么样的变化呢？**

当你打开不同的站点的网站的时候，就会开启新的渲染引擎。

**总结：渲染进程策略**

- 打开新的页面都会使用单独的渲染进程；
如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；
- A和B不是同一站点，浏览器进程则会为 B 创建一个新的渲染进程。

**4. 提交文档**
文档指的是URL请求的响应体数据。

- 浏览器发送“提交文档”的消息->渲染进程收到“提交文档”消息后，会和网络进程建立传输数据的“管道”。
- 等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程。
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。

**更新内容如下图所示：**

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/1722347e7741b53c.png)
<center>导航完成状态</center>

**5. 渲染阶段**
文档被提交，渲染进程开始页面解析和子资源加载。当 页面生成完成，渲染进程会发送一个消息更给浏览器进程，浏览器接受消息后，会听着i标签图表上的加载动画。

![](https://cdn.jsdelivr.net/gh/hzy1257664828/Images/img/172234a142457406.png)
<center>渲染结束</center>

所以，我们了解了**从输入 URL 到页面展示，这中间发生了什么？**

<font color=red>补充</font>:

**问题(1)**

为什么说这个网站新开的页面都是新开一个渲染进程？
```
<a target="_blank" rel="noopener noreferrer" class="hover" href="https://linkmarket.aliyun.com/hardware_store?spm=a2c3t.11219538.iot-navBar.62.4b5a51e7u2sXtw" data-spm-anchor-id="a2c3t.11219538.iot-navBar.62">硬件商城</a>
```
**答**:
- 使用noopener noreferrer就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。

**问题(2)**

http的keepalive的connection是什么粒度复用的呢？

**答**:

- 首先keep-alive是为了解决连接效率不高的问题，http1.0时代，http请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接，通常，建立连接和断开连接的时间就有可能超过传输数据的时间了，这种短连接的效率是异常的低效。

- 针对短连接低效的问题，后面就出现了长连接，也就是这里要讲的keep-alive。

- 可以把长连接看成是一个管道，一个http请求结束之后，不会关闭连接，下个请求可以复用该连接，这样就省去建立连接和断开连接的时间了，但是他们请求是按照顺序，也就是符合IP+端口规则的资源都可以复用该连接，这就回答了上面提的这个问题。

- 但是，使用keep-alive同样存在问题，比如一个页面可能有100张图片素材，假设这些图片素材都保存在同一个域名下面，如果只复用一个http管道的话，那么传输100张图片的素材也是非常耗时间的，这就出现了同一时刻并发连接服务器的需求，也就是文中提到同一时刻，对同一域名下面，只能可以发起6个请求，这样就可以大大提升请求效率了。

- 为什么是6个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。